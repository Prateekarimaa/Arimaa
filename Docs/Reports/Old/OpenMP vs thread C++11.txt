OpenMP was designed as a lightweight data-parallel addition to FORTRAN and C, later extended to C++ idioms (e.g. parallel loops over random-access iterators) and to task parallelism with the introduction of explicit tasks. It is meant to be as portable across as many platforms as possible and to provide essentially the same functionality in all three languages. Its execution model is quite simple - a single-threaded application forks teams of threads in parallel regions, runs some computational tasks inside and then joins the teams back into serial execution. Each thread from a parallel team can later fork its own team if nested parallelism is enabled.

OpenMP 4.0 is also not going further than ISO/IEC 14882:1998 for the C++ features it employs (the SC12 draft is here). The standard now includes things like portable thread affinity - this definitely does not play well with other threading paradigms, which might provide their own binding mechanisms that clash with those of OpenMP. Once again, the OpenMP language is targeted at HPC (data and task parallel scientific and engineering applications). The C++11 constructs are targeted at general purpose computing applications. If you want fancy C++11 concurrent stuff, then use C++11 only, or if you really need to mix it with OpenMP, then stick to the C++98 subset of language features if you want to stay portable.

Both API do not have the same objective. For software development PTHREAD may be better, for HPC and scientific applications OpenMP may be better (because it works faster and it is made to work on loop or fast creation/destruction). Moreover, OpenMP usually creats thread at the first parallel statement it encounter (and will destroy thread only at the end) also we can use active waiting in OpenMP, which COST a lot and use CPU intensively but in the HPC world we do not care as long as it goes faster. At the contrary POSIX thread are created and destroyed etc. this is why in my test they are slower since we focus on the creation.

OpenMP			Intel TBB			C++11 Threads
+ Options 		+ Possibilities 	+ Flexibility
+ Portable		+ Management 		+ Type-Safety
+ Languages 	+ Maintenance 		+ Possibilities
- Performance 	- Language 			- Fortran
- Memory 		- OOP 				- Compiler
- Unreliable 	- Control 			- Scaling