One of the advantages of the MCTS algorithm is its generalization. In fact it can be applied to a lot of games. We decided to keep this generalization, therefore we thought about two solutions.

One of them is Genaral Game Playing, a formal language which allows software to create the model given its formal rules. However the problem of this approach is that even if it permits to play unknowed games, it prevents the use of efficient heuristic to improve the algorithms.
So we decided to choose a second way which consists to exploit the properties of MCTS algorithm. 
It does not need to know the rules, only the moves. With this in mind we created an interface for the game which define the methods that MCTS algorithm requires. In other words our algorithm is compatible with all the two-players games implemented with this interface.

Only the following fonctions are required : 
\begin{itemize}
\item return all the possible moves given position
\item play a random move
\item play a chosen move 
\item play random moves until the end of the game
\item return whether the game is not finished or who won
\end{itemize}

The main application of our algorithm is the Arimaa game. Therefore we will be able to specialize our algorithm for it in order to improve its efficiency. The main problem is the branching factor\footnote{In a tree, the branching factor is the number of children at each node.} of the Arimaa game which average is 17 281 and reaches about 22 000 after 10 moves\footnote{http://arimaa.janzert.com/bf\_study/}.\\

\begin{center}
	\begin{tabular}{ | c | c |}
		\hline Game & Average number of possible moves \\ \hline
		\hline  
		Othello & 8\\
		\hline  
		Chess & 35\\
		\hline  
		Game of Go & 250\\
		\hline
		Arimaa & 17 281\\
		\hline
	\end{tabular}
\end{center}

The branching factor of a game is important because it increases greatly the space that has to be searched to guess what will happend multiple moves ahead. In chess after 4 moves, the number of positions evaluated are about 35\textsuperscript{4} which is roughtly equivalent to 1,8 billion. In Arimaa, after 3 turns (yours, the opponent and yours again), if you were to explore all positions, you would need to evaluate around 5,2 trillions\footnote{1 trillion in short scale = 1 thousand billion = 10\textsuperscript{12}.} boards. It is about 2000 times more than \textit{Chess} with half the number of moves).

In order to decrease the space to be search, our MCTS Algorithm will perform a big number of simulations before chosing the nodes to explore. After the selection, it will prune the tree in order to optimise search speed and the memory management.

\begin{figure}[H]
\centering
	\includegraphics[width=\textwidth]{3Methods/3.2MCTS/img/root.png}
	\caption{\label{fig:root}Root.}
\end{figure}

\begin{figure}[H]
\centering
	\includegraphics[height=2.5cm]{3Methods/3.2MCTS/img/prune.png}
	\caption{\label{fig:prune}Prune.}
\end{figure}

\begin{figure}[H]
\centering
	\includegraphics[height=2.5cm]{3Methods/3.2MCTS/img/prune-clean.png}
	\caption{\label{fig:prune-clean}Prune-clean.}
\end{figure}

\begin{figure}[H]
\centering
	\includegraphics[width=\textwidth]{3Methods/3.2MCTS/img/depth1.png}
	\caption{\label{fig:depth1}Depth1.}
\end{figure}

\begin{figure}[H]
\centering
	\includegraphics[width=\textwidth]{3Methods/3.2MCTS/img/depth1-select.png}
	\caption{\label{fig:depth1-select}Depth1-select.}
\end{figure}

\begin{figure}[H]
\centering
	\includegraphics[height=4cm]{3Methods/3.2MCTS/img/depth1-prune.png}
	\caption{\label{fig:depth1-prune}Depth1-prune.}
\end{figure}
